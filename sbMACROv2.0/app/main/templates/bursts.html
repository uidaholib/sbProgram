{% extends "base.html" %} {% block content %}

<script src="https://d3js.org/d3.v5.min.js"></script>
<script>
	var d3v5 = window.d3;
	window.d3 = null;
</script>

<!-- <script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="//code.jquery.com/jquery-1.10.2.js"></script> -->

<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>


<link rel="stylesheet" href="{{ url_for('main.static', filename='css/modal.css') }}"/>

<link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/smoothness/jquery-ui.css">
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="//code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

<style>
	path {
	    stroke: #ccc;
	    stroke-width: 2;
	    fill: none;
	}
	.axis path,
	.axis line {
	    fill: none;
	    stroke: grey;
	    stroke-width: 1;
	    shape-rendering: crispEdges;
	}
	.phrase {
		font: 14px -apple-system, BlinkMacSystemFont, Roboto, Helvetica, Arial, sans-serif;
	}
	.ui-tooltip a {
		color: blue;
	}
	.ui-tooltip a:hover {
		color: grey;
		text-decoration: underline;
	}
	.header_info_icon {
		height: 20px;
		width: 20px;
		margin-bottom: 10px;
	}
	.slider_info_icon {
		height: 15px;
		width: 15px;
	}
	.tl_tooltip {
		min-width: 100px;
		min-height: 45px;
		font: 12px -apple-system, BlinkMacSystemFont, Roboto, Helvetica, Arial, sans-serif;
		color: #ffffff;
		background: rgba(0, 0, 0, 0.8);
		box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.33333);
		padding: 10px 15px;
		border-radius: 4px;
	}
	div.lc_tooltip {   
	 	position: absolute;
		text-align: center;              
		padding: 2px;             
		font: 12px sans-serif;
		border: 0px;      
		border-radius: 8px;           
		pointer-events: none;         
	}
	.double-line {
	    border: none;
	    border-top: 3px double #333;
	    color: #333;
	    overflow: visible;
	    text-align: center;
	    height: 5px;
	}
	.double-line:after {
	    background: #fff;
	    content: '*';
	    padding: 0 4px;
	    position: relative;
	    top: -10px;
	}
	/*  https://css-tricks.com/examples/hrs/  */
	.gradient-line {
	    border: 0;
	    height: 1px;
	    background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 2), rgba(0, 0, 0, 0));
	}
	input[type=range]{
	    width: 80%;
	    margin: 15px 7px 0 0;
	}
	.slidecontainer {
		/*margin: 0 auto;*/
		margin-top: 5px;
		/*margin-left: 40%;*/
		/*width: 50%;*/
	}
	.slider {
		height: 10px;
	}
	input[type=range]::-webkit-slider-runnable-track {
	    height: 5px;
	    background: #ddd;
	    border: none;
	    border-radius: 3px;
	}
	input[type=range]::-webkit-slider-thumb {
	    /*-webkit-appearance: none;*/
	    border: none;
	    height: 16px;
	    width: 16px;
	    border-radius: 50%;
	    background: goldenrod;
	    margin-top: -4px;
	}
	input[type=range]:focus {
	    outline: none;
	}
	input[type=range]:focus::-webkit-slider-runnable-track {
	    background: #ccc;
	}
	input[type=range]:focus::-ms-fill-lower {
	    background: rgb(0, 0, 255);
	}
	input[type=range]:focus::-ms-fill-upper {
	    background: #ccc;
	}

	/* Radio button */
	input[type="radio"]:not(:checked)+span, [type="radio"]:checked+span {
	    padding-left: 25px;
	    height: 18px;
	}
	input[type="checkbox"]:not(:checked)+span, [type="checkbox"]:checked+span {
	    padding-left: 22px;
	    height: 18px;
	}
	.radiocontainer {
		display: block;
		position: relative;
		width: 20%;
		cursor: pointer;
		font-size: 100%;
		float: left;
	}
	.checkboxcontainer {
		display: block;
		position: relative;
		width: auto;
		cursor: pointer;
		font-size: 100%;
		margin-left: 3px;
		float: left;
	}

	/* Hide the browser's default radio button */
	.radiocontainer input {
	  /*position: absolute;
	  opacity: 0;
	  cursor: pointer;*/
	}

	/* Create a custom radio button */
	.checkmark {
		margin-left: 0;
	  /*position: absolute;
	  top: 0;
	  left: 0;
	  height: 5px;
	  width: 1px;
	  background-color: #eee;
	  border-radius: 10%;*/
	}

	/* On mouse-over, add a grey background color */
	.radiocontainer:hover input ~ .checkmark {
	  /*background-color: #ccc;*/
	}

	/* When the radio button is checked, add a blue background */
	.radiocontainer input:checked ~ .checkmark {
	  /*background-color: #2196F3;*/
	}

	/* Create the indicator (the dot/circle - hidden when not checked) */
	.checkmark:after {
	  /*content: "";*/
	  /*position: absolute;*/
	  /*display: block;*/
	}

	/* Show the indicator (dot/circle) when checked */
	.radiocontainer input:checked ~ .checkmark:after {
	  display: block;
	}

	/* Style the indicator (dot/circle) */
	.radiocontainer .checkmark:after {
	 	/*top: 0;
		left: 0;
		width: 50%;
		height: 50%;
		border-radius: 100%;
		background: white;*/
	}
	#lc_casc_dropdown,
	#tl_casc_dropdown
	{
		position:absolute;
		width: 210px;
		/*left: 38%;*/
	}
	#phrases_label{
		position:relative;
		top:18px;
		width: 20px;
	}
	#showAll{
		position:relative;
		top: 20px;
		left: 0px;
	}
	#clearAll{
		position: relative;
		top: 22px;
	}
	#legendContainer{
		position: relative;
		float: left;
		top: 30px;
		width: 110px;
	}
	#legend{
		position: relative;
		width: 100px;
		/*height:300px;*/
	}
	.chart_legend {
	    font-size: 12px;
	    font-weight: normal;
	    text-anchor: left;
	}
	.legendcheckbox{
		cursor: pointer;
	}
</style>

	<h4>
		Research Pulses & Bursts
		<img id="pulse_burst_info" src = "{{ url_for('main.static', filename='info.png') }}" class = "header_info_icon">
	</h4>
<hr size="20" noshade="noshade">

<!-- Tooltips -->
<div class="tl_tooltip"></div> <!-- Timeline tooltip -->
<div class="lc_tooltip"></div> <!-- Linechart tooltip -->

<!-- PULSES -->
<br>
<p>
	<h5>PULSES</h5>
	<blockquote>
		<i>A <b>pulse</b> is an upward trend in the frequency of occurrence of a phrase or topic</i>
	</blockquote>
</p>
<!-- <hr class="double-line" width="39%"> -->

<div style="margin-left: 10%">
	<div id = 'tl_casc_dropdown' >
		<!-- <label for = "cascs" style="font-size:80%; text-align:left">CASCs</label> -->
	</div>

	<button class="btn wave-effect waves-teal" style="margin-left: 20%; margin-top: 2px" onclick="downloadCSVFromJson('timeline')">
		Download Pulses
	</button>
</div>

<br>

<div style="margin-left: 10%">
	<fieldset style="width: 85%">
		<legend>Sort pulses by</legend>
			
			<div id="tl_sort_options">
				<label class="radiocontainer">
					<input type="radio" name="sort_criterion" value="strength" checked>
					<span class="checkmark"></span> Intensity
				</label>
				<label class="radiocontainer">
					<input type="radio" name="sort_criterion" value="start">
					<span class="checkmark"></span> Start Year
				</label>
				<label class="radiocontainer">
					<input type="radio" name="sort_criterion" value="end">
					<span class="checkmark"></span> End Year
				</label>
				<label class="radiocontainer">
					<input type="radio" name="sort_criterion" value="duration">
					<span class="checkmark"></span> Duration
				</label>
			</div>
			<br>
			<div>
				<label class="checkboxcontainer">
					<input type="checkbox" name="sort_criterion" value="duration">
					<span class="checkmark"></span> Sort ascending (lowest to higest)
				</label>
			</div>
	</fieldset>
	<fieldset style="width: 40%; margin-top: 20px; margin-bottom: 20px; float: left;">
		<legend>Number of Pulses</legend>
		<div class="slidecontainer">
			<output id="num_phrases"></output>
			<input id="num_phrases" type="range" class="slider">
			<output id="num_display"></output>
		</div>
		<div style="width: 50%">
			<button class="btn wave-effect waves-teal" style="margin-top: 10px; font-size: 12px; padding: 0 8px; float: left;" onclick="updateCharts()">
				Update Pulses
			</button>
		</div>
		<text style="font-size: 12px; margin-top: 10px"><br>&nbsp;&nbsp;<--&nbsp;useful after excluding phrases</text>
	</fieldset>
	<fieldset style="width: 40%; margin-left: 5%; margin-top: 20px; margin-bottom: 20px; float:left;">
		<legend>Exclusion List</legend>
		<div>
			<select id="ex_list" multiple style="margin-left: 5px; height: 100px; width: 70%; float: left; display: block;"></select>
			<button class="btn wave-effect waves-teal" style="margin-left: 10px; margin-top: 55px; font-size: 12px; padding: 0 8px;" onclick="writeExclusionList()">
				Confirm
			</button>
		</div>
	</fieldset>
	<div style="clear: both;"></div>
	<b>Pulses are shaded by intensity: deeper shades => stronger pulses</b><br>
	<i>- Click on a phrase or bar below for more information on the pulse items</i><br>
	<i>- Ctrl + click on a phrase or bar below to exclude it from any further analysis</i><br>
	<i>- Ctrl + click on a phrase in the exclusion list above to restore it</i><br>
	<br>
	<div id = "timeline"></div>
</div>

<!-- BURSTS -->
<br>
<p><hr class="gradient-line" width="80%"></p>
<p>
	<h5>BURSTS</h5>
	<blockquote>
		<i>A <b>burst</b> occurs when a pulse crosses a specified threshold</i>
	</blockquote>
</p>
<!-- <hr class="double-line" width="39%"> -->

<div>
	<div style="margin-left: 10%">

		<div>
			<div id = 'lc_casc_dropdown'>
				<!-- <label for = "cascs" style="font-size:80%; text-align:left">CASCs</label> -->
			</div>

			<button class="btn wave-effect waves-teal" style="margin-left: 20%; margin-top: 2px" onclick="downloadCSVFromJson('linechart')">
				Download Bursts
			</button>

		</div>

		<br>

		<fieldset style="width: 85%">
			<legend>Burst Parameters</legend>

			<div class="slidecontainer" style="width: 50%; float: left;">

				<output id="num_bursts">Number of bursts to display</output>
				<input id="num_bursts" type="range" class="slider">
				<br>
				<output id="num_bursts_display"></output>

				<div class="slidecontainer" style="width: 100%; float: left;">
					<output id="win_size">
						Smoothing window size
						<img id="win_size_info" src = "{{ url_for('main.static', filename='info.png') }}" class = "slider_info_icon">
					</output>
					<input id="win_size" type="range" class="slider">
					<br>
					<output id="win_size_display"></output>
				</div>

			</div>

			<fieldset>
				<legend></legend>
				<div class="slidecontainer" style="width: 100%">
					<output id="threshold">
						Burst threshold
						<img id="threshold_info" src = "{{ url_for('main.static', filename='info.png') }}" class = "slider_info_icon">
					</output>
					<input id="threshold" type="range" class="slider">
					<br>
					<output id="threshold_display"></output>
				</div>
				<br>
				Number of bursts above this threshold:
				<br>
				<output id="threshold_bursts_display"></output>
			</fieldset>

			<p><hr class="gradient-line" width="80%"></p>
			<div>
				<i>Click the colored legend rectangles below to select/deselect bursts</i><br>
				<i>Click on a phrase in the legend for more information on the burst items</i><br>
				<br>
				<i>Ctrl + click on a phrase in the legend below to exclude it from any further analysis</i><br>
				<i>Ctrl + click on a phrase in the exclusion list above to restore it</i>
			</div>

		</fieldset>
	</div>

	<br><br>

	<div>
		<div>
			<div id = "chart_div" style="float: left; width: 80%"></div>
			<div style="float: left; width: 20%">
				<div id = 'phrases_label'>
					<label  style="font-size:80%; text-align:left">BURSTS</label>
				</div>
				<div id="showAll">
					<input name="showAllButton"
					 type="button"
					 value="Show All"
					 onclick="showAll()" />
				</div>

				<div id="clearAll">
					<input name="clearAllButton"
					 type="button"
					 value="Clear All"
					 onclick="clearAll()" />
				</div>

				<div id="legendContainer" class="legendContainer">
					<svg id="lineChart_legend"></svg>
				</div>
			</div>
		</div>
	</div>
</div>



<!-- MODAL -->
<div id="modal" class="projModal">
  <!-- Modal content -->
	<div class="projModal-content">
		<div class="projModal-header">
			<span class="close">&times;</span>
			<h5></h5>
		</div>

		<div class="row">
			<span style="font-size: 2vh;">
				<div id = 'details_div' style = 'text-align: justify; text-justify: inter-word'></div>
			</span>
		</div>

		<div class="projModal-footer">
		<h8>sbMACRO</h8>
		</div>

	</div>

</div>

<script>

	var cascs = [
					"All CASCs",
					"Alaska",
					"North Central",
					"Northeast",
					"Northwest",
					"Pacific",
					"South Central",
					"Southeast",
					"Southwest",
					"National"
				],
	years = [2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018],
	default_casc = "All CASCs";
	exclusion_list = [];
	all_excluded_phrases = [];
	exclusions_file = 'exclusions.csv';
	// timeline
	sort_labels = ['Strength', 'Start', 'End', 'Duration'],
	default_sort_option = 0,
	static_data_path = '/static/main/',
	bursts_data_path = '/static/main/bursts/',
	counts_data_path = '/static/main/counts/',
	tl_selectedIndex = 0,
	tl_selected_sort = 'strength',
	default_num_bursts = 5,
	ascending = false,
    scale_factor = 1,
    dataNest = null,
    // line chart
	lc_color_map = null,
	lc_legend = null,
	burst_data = [],
	// curr_list = [],
	// master_list = [],
	color_dict = {},
	lc_selectedCascIndex = 0,
	total_num_phrases = 0,
	default_num_to_plot = 5;

    // default burst computation variables
	max_num_bursts = 15;
	default_num_bursts = 10;
	max_win_size = 10;
	default_win_size = 1;
    default_p_threshold = 0.0007,
	// last_index = default_num_bursts - 1;

	parseDate = d3v5.timeParse("%Y");

	// // https://github.com/d3/d3-scale-chromatic
	// lc_color_map = d3.scale.linear().domain(d3.extent([0, max_num_bursts - 1])).range([0, 1]);
	// colors = [];
	// for (i = 0; i < max_num_bursts; i++) {
	// 	colors.push(d3.interpolateWarm(lc_color_map(i)));
	// }

	// colors = d3.merge([d3.schemePaired, [d3.schemeSet1[0]], [d3.schemeSet1[5]], [d3.schemeCategory10[5]]]);
    colors = ['#21618C', '#3498DB', '#AED6F1', '#00838F', '#00BFA5',
              '#F1C40F', '#F9E79F', '#E67E22', '#E6B0AA', '#D7BDE2',
              '#196F3D', '#4CAF50', '#A9DFBF', '#7986CB', '#555555'];
	color_status = [];
	colors.forEach(function(d) {
		color_status.push('available');
	})

	// Timeline
	var tl_casc_dropdown = d3v5.select("#tl_casc_dropdown")
							   .append("select")
							   .attr("id", "tl_casc_dropdown")
							   .style("width", "60%")
							   .style("display", "block");

	tl_casc_dropdown.selectAll("option")
					.data(cascs)
					.enter()
					.append("option")
					.text(function(d, i) { return d; })
					.attr("value", function (d, i) { return i; });
		
	tl_casc_dropdown.property("selectedIndex", tl_selectedIndex)
				.on("change", function(d) {

					var selected_casc = cascs[this.value];

					new_num_to_plot = +d3v5.select("output#num_display").property("value");

					updateTimeline(selected_casc, new_num_to_plot, tl_selected_sort, ascending);
				});

	sort_options = d3v5.selectAll("input[type = radio]")
					   .on("change", function(d) {
					   		tl_selected_sort = this.value;

							tl_selectedCascIndex = tl_casc_dropdown.property('selectedIndex');
							var selected_casc = cascs[tl_selectedCascIndex];

							new_num_to_plot = +d3v5.select("output#num_display").property("value");

							updateTimeline(selected_casc, new_num_to_plot, tl_selected_sort, ascending);
					   });

	sort_options = d3v5.selectAll("input[type = checkbox]")
					   .on("change", function(d) {
					   		// toggle ascending status
					   		ascending = !ascending;

							tl_selectedCascIndex = tl_casc_dropdown.property('selectedIndex');
							var selected_casc = cascs[tl_selectedCascIndex];

							new_num_to_plot = +d3v5.select("output#num_display").property("value");

							updateTimeline(selected_casc, new_num_to_plot, tl_selected_sort, ascending);
					   });

	tl_svg = d3v5.select("#timeline")
			     .append("svg");

	// Line Chart
	var lc_margin = {top: 10, right: 20, bottom: 30, left: 50},
		lc_main_width = 700,
		lc_main_height = 400,
	    lc_width = lc_main_width - lc_margin.left - lc_margin.right,
	    lc_height = lc_main_height - lc_margin.top - lc_margin.bottom;
	    // lc_tooltip = { width: 100, height: 100, x: 10, y: -30 };
	    
	var lc_svg = d3.select("#chart_div")
				   .append("svg")
				   .attr("width", lc_width + lc_margin.left + lc_margin.right)
				   .attr("height", lc_height + lc_margin.top + lc_margin.bottom)
				   // .attr("viewBox", "0 0 " + 700 + " " + 400)
				   // .attr("preserveAspectRatio", "xMinYMin meet")
				   .append("g")
				   .attr("transform", "translate(" + lc_margin.left + "," + lc_margin.top + ")");

	// var aspect = lc_main_width / lc_main_height,
	//     chart_div = d3.select('#chart_div');
	// d3.select(window)
	//   .on("resize", function() {
	//     var targetWidth = chart_div.node().getBoundingClientRect().width;
	//     chart_div.attr("width", targetWidth);
	//     chart_div.attr("height", targetWidth / aspect);
	//   });

	var x = d3.scale.linear().range([0, lc_width]);
	var y = d3.scale.linear().range([lc_height, 0]);

	var xAxis = d3.svg.axis()
					  .scale(x)
					  .orient("bottom")
					  .tickFormat(d3.format(".0"));

	var yAxis = d3.svg.axis()
					  .scale(y)
					  .orient("left");

	yAxis.ticks();

	var phraseline = d3.svg.line()
						   .interpolate("monotone")
						   .x(function(d) { return x(d[0]); })
						   .y(function(d) { return y(d[1]); });

	var lc_casc_dropdown = d3.select("#lc_casc_dropdown")
								.append("select")
								.attr("id", "lc_casc_dropdown")
								.style("width", "60%")
								.style("display", "block");

	lc_casc_dropdown.selectAll("option")
					  .data(cascs)
					  .enter()
					  .append("option")
					  .text(function(d, i) { return d; })
					  .attr("value", function (d, i) { return i; });

    lc_casc_dropdown.property("selectedIndex", lc_selectedCascIndex)
				    .on("change", function() {
				     	// get selected CASC
						lc_selectedCascIndex = lc_casc_dropdown.property('selectedIndex');
						var selected_casc = cascs[lc_selectedCascIndex];
				     	
				     	// reset color_dict and color_status
						color_dict = {};
						for (i = 0; i < color_status.length; i++) {
							color_status[i] = 'available';
						}

						updateLineChart(selected_casc, default_p_threshold, default_win_size, default_num_bursts);
					 });

	margin = ({top: 20, right: 20, bottom: 20, left: 20});

	pulse_burst_tip = 'This sbMacro application defines a <b>pulse</b> as an upward trend in the frequency of occurrence of a phrase or topic.<br><br>A <b>burst</b> occurs when a pulse crosses a specified threshold.<br><br>Based on <a href="https://www.cs.cornell.edu/home/kleinber/bhs.pdf" target="_blank">Kleinberg\'s "bursty stream analysis"</a>, the burst analysis on this page is modeled after <a href="https://github.com/nmarinsek/burst_analysis/blob/master/fMRIarticle_bursts.ipynb" target="_blank">an implementation</a> on github by <a href="https://nikkimarinsek.com/">Nikki Marinsek</a>.';

	win_size_tip = 'When similar bursts are plotted very close to (or overlap with) each other, modifying the window size can help to separate them by magnifying tiny differences between them.<br><br>The resulting burst shapes and heights are not the true shapes and heights, but the order or arrangement of the bursts represent the true state (i.e., if burst A is displayed above burst B, then in practice burst A is a stronger burst).';

	threshold_tip = 'For every phrase or topic, a relative frequency of occurrence is computed by comparing it to every other phrase or topic in the selection.<br><br>A phrase or topic with a relative frequency higher than the threshold is considered to be a burst.';


	setup_tooltip('#pulse_burst_info', 'img.header_info_icon', pulse_burst_tip);
	setup_tooltip('#win_size_info', 'img.slider_info_icon', win_size_tip);
	setup_tooltip('#threshold_info', 'img.slider_info_icon', threshold_tip);

	// https://stackoverflow.com/a/16663648/8379443
	function setup_tooltip(target_element, target_item, tooltip_message) {
		$(target_element).tooltip({
		    items: target_item,
		    content: tooltip_message,
		    show: null, // show immediately
		    open: function(event, ui)
		    {
		        if (typeof(event.originalEvent) === 'undefined')
		        {
		            return false;
		        }
		    
		        var $id = $(ui.tooltip).attr('id');
		    
		        // close any lingering tooltips
		        $('div.ui-tooltip').not('#' + $id).remove();
		        
		        // ajax function to pull in data and add it to the tooltip goes here
		    },
		    close: function(event, ui)
		    {
		        ui.tooltip.hover(function()
		        {
		            $(this).stop(true).fadeTo(400, 1); 
		        },
		        function()
		        {
		            $(this).fadeOut('400', function()
		            {
		                $(this).remove();
		            });
		        });
		    }
		});
	}


	// https://observablehq.com/@campegg/writers-timeline

	function updateTimeline(casc, num_to_plot, sort_type, ascending) {

		// remove previous content
		d3v5.select("#timeline svg").remove();
		d3v5.select(".tl_tooltip").remove();

		var burst_file = casc.toLowerCase().replace(' cascs', '').replace(' ', '_') + '_bursts.json';

		yr_counts_file = casc.toLowerCase().replace(' cascs', '').replace(' ', '_') + '_yr_phrase_counts.json';
		d3.json(counts_data_path + yr_counts_file, function(yr_phrase_counts) {

			// get years for this casc
			casc_years = [];
			// build an array of the years
			Object.keys(yr_phrase_counts).forEach(function(k) {
				casc_years.push(yr_phrase_counts[k]['year']);
			});
	
			d3v5.json(bursts_data_path + burst_file).then(function(burst_data) {

				d3v5.csv(static_data_path + exclusions_file).then(function(excluded_phrases) {
				
					all_excluded_phrases = d3v5.merge([dictColumn(excluded_phrases, 'phrase'), exclusion_list]);

					// filter out exclusion_list
					burst_data = burst_data.filter(function(d) {
						return all_excluded_phrases.indexOf(d.label) == -1;
					})

					// get number of bursts to display
					total_num_bursts = d3v5.min([50, burst_data.length]);

					// set slider display texts
					d3v5.select("output#num_display").text(num_to_plot);

					data = burst_data.map(d => {
						return {
							name: d.label,
							burst_start: parseDate(casc_years[d.begin]),
							burst_end: parseDate(casc_years[d.end]),
							weight: d.weight
						}
					});

					category = '';
					switch (sort_type) {
						case 'strength':
							if (ascending) {
								category = 'Weakest';
								data = data.sort(function(a, b) {
									return d3v5.ascending(a.weight, b.weight);
								});
							}
							else {
								category = 'Strongest';
								data = data.sort(function(a, b) {
									return d3v5.descending(a.weight, b.weight);
								});
							}
							break;
						case 'start':
							if (ascending) {
								category = 'Latest';
								data = data.sort(function(a, b) {
									return d3v5.descending(a.burst_start, b.burst_start);
								});
							}
							else {
								category = 'Earliest';
								data = data.sort(function(a, b) {
									return d3v5.ascending(a.burst_start, b.burst_start);
								});						
							}
							break;
						case 'end':
							if (ascending) {
								category = 'Earliest';
								data = data.sort(function(a, b) {
									return d3v5.ascending(a.burst_end, b.burst_end);
								});
							}
							else {						
								category = 'Latest';
								data = data.sort(function(a, b) {
									return d3v5.descending(a.burst_end, b.burst_end);
								});
							}
							break;
						case 'duration':
							if (ascending) {
								category = 'Shortest';
								data = data.sort(function(a, b) {
									return d3v5.ascending(a.burst_end - a.burst_start, b.burst_end - b.burst_start);
								});
							}
							else {
								category = 'Longest';
								data = data.sort(function(a, b) {
									return d3v5.descending(a.burst_end - a.burst_start, b.burst_end - b.burst_start);
								});
							}
							break;	
					}

					// set the slider header text
					description = (sort_type == 'start' || sort_type == 'end')? 'pulse ' + sort_type : 'pulse';
					if (num_to_plot == 0) { d3v5.select("output#num_phrases").text(""); }
					else if (num_to_plot == 1) { d3v5.select("output#num_phrases").text(category + " " + description); }
					else { d3v5.select("output#num_phrases").text(category + " " + num_to_plot + " " + description + "s"); }


					data = data.slice(0, num_to_plot);

					color_map = d3v5.scaleLinear()
									.domain([d3v5.min(data, d => d.weight), d3v5.max(data, d => d.weight)])
									.range([0, 1]);
					mid_domain = (color_map.domain()[0] + color_map.domain()[1])/2;

					dimensions = ({
						phrase: data.length,
						barHeight: 20,
						barPadding: 10,
						width: 700,
						get height() {
							return (this.phrase * (this.barHeight + this.barPadding)) + (margin.top + this.barPadding) + margin.bottom
						}
					});

					tl_x = d3v5.scaleTime()
							.domain([d3v5.min(data, d => d.burst_start), d3v5.max(data, d => d.burst_end)])
							.range([margin.left, dimensions.width - margin.right]);

					tl_y = d3v5.scaleLinear()
						 	.range([0,dimensions.height - margin.bottom - margin.top]);

					// create the svg
					tl_svg = d3v5.select("#timeline")
							  .append("svg")
							  .attr("width", dimensions.width)
							  .attr("height", dimensions.height)
							  .attr("viewBox", [0, 0, dimensions.width*scale_factor, dimensions.height*scale_factor]);

					// // moving reference line
					// line = tl_svg.append("line")
					// 		  .attr("y1", margin.top)
					// 		  .attr("y2", dimensions.height - margin.bottom)
					// 		  .attr("stroke", "rgba(128, 0, 0, 0.33333)")
					// 		  .style("pointer-events","none");

					// tl_svg.on("mousemove", function(d) {
					// 	let [x, y] = d3v5.mouse(this);
					// 	line.attr("transform", `translate(${x} 0)`);
					// })

					// set up tooltips
					tl_tooltip = d3v5.select("body")
					              .append("div")
					              .attr("class", "tl_tooltip")
					              .style("position", "absolute")
					              .style("opacity", 0);

					info_tooltip = d3v5.select("body")
						               .append("div")
						               .attr("class", "info_tooltip")
						               .style("position", "absolute")
						               .style("opacity", 0);

					// top axis
					tl_svg.append("g")
					 .call(d3v5.axisTop(tl_x).ticks(d3v5.timeYear))
					 .attr("font-size", 14)
					 .attr("font-family", "-apple-system, BlinkMacSystemFont, Roboto, Helvetica, Arial, sans-serif")
					 .attr("transform", `translate(0, ${margin.top})`);

					// bottom axis
					tl_svg.append("g")
					 .call(d3v5.axisBottom(tl_x).ticks(d3v5.timeYear))
					 .attr("font-size", 14)
					 .attr("font-family", "-apple-system, BlinkMacSystemFont, Roboto, Helvetica, Arial, sans-serif")
					 .attr("transform", `translate(0, ${dimensions.height - margin.bottom})`);

					// gridlines
					tl_svg.append("g")
					 .call(d3v5.axisTop(tl_x)
					         .tickFormat("")
					         .tickSize(-(dimensions.height - margin.top - margin.bottom))
					      )
					 .attr("transform", `translate(0, ${margin.top})`)
					 .attr("stroke-width", "1px")
					 .attr("opacity", "0.125");

					// plot the data
					tl_svg.append("g")
						.selectAll("rect")
						.data(data)
						.join("rect")
						.attr("id", function(d) { return "bar_" + getID(d.name); })
						.attr("class", "phrase")
						.attr("x", function(d, i) {return tl_x(d.burst_start)})
						.attr("y", function(d, i) {return ((margin.top + dimensions.barPadding) + (i * (dimensions.barHeight + dimensions.barPadding)))})
						// .attr("width", function(d, i) {return (d.burst_end ? tl_x(d.burst_end) : tl_x(today)) - tl_x(d.burst_start)})
						.attr("width", function(d, i) { return 20 + tl_x(d.burst_end) - tl_x(d.burst_start); })
						.attr("height", dimensions.barHeight)
						.attr("fill", function(d) {
							return (d3v5.interpolateBlues(color_map(d.weight)));
						})
			            .on("click", function(d) {
			            	// https://octoperf.com/blog/2018/04/18/d3-js-drag-and-drop-tutorial/
			            	if (d3v5.event.ctrlKey) {
			            		exclusion_list.push(d.name);
					            // d3v5.select(this).remove();
					            // d3v5.select("text[class=phrase]#bar_" + getID(d.name)).remove();
					            d3.selectAll("#line_" + getID(d.name)).remove();
							    d3.selectAll("#bar_" + getID(d.name)).remove();
					            tl_tooltip.style("opacity", 0);
					        } else {
			            		displayModal(d, 'name');
					        }
					        d3v5.event.stopPropagation();

					        // display exclusion list
							ex_list = d3v5.select("#ex_list")
										  .selectAll("option")
									      .data(exclusion_list)
									      .enter()
									      .append("option")
									      .text(function(phrase, i) { return phrase; })
									      .attr("value", function (phrase, i) { return i; })
									      .on("click", function(phrase) {
										      	if (d3v5.event.ctrlKey) {
										      		// remove phrase from exclusion_list and redo timeline
										      		var index = exclusion_list.indexOf(phrase);
										      		if (index > -1) { exclusion_list.splice(index, 1); }
										            d3v5.select(this).remove();
										            updateCharts();
										        }
										        d3v5.event.stopPropagation();
									      })
									      .exit()
									      .remove();
			            });

					// add labels
					tl_svg.append("g")
						.selectAll("text")
						.data(data)
						.join("text")
						.text(function(d) { return d.name; })
						.style("font-size", 14)
						.attr("id", function(d) { return "bar_" + getID(d.name); })
						.attr("class", "phrase")
						.attr("fill", function(d){
							return (d.weight > mid_domain && d.burst_start.getFullYear() != d3v5.max(tl_x.domain()).getFullYear() && this.getBBox().width < tl_x(d.burst_end) - tl_x(d.burst_start))? "#fff" : "#004d66";
						})
						.attr("x", function(d, i) {
							// https://stackoverflow.com/a/14569745/8379443
							if ((d.burst_start.getFullYear() == d3v5.max(tl_x.domain()).getFullYear())) {
								return tl_x(d.burst_start) - this.getBBox().width - (dimensions.barPadding * 0.3);
							}
							else{ 
								return (this.getBBox().width > 20 + tl_x(d.burst_end) - tl_x(d.burst_start))? 20 + tl_x(d.burst_start) + 0.3*dimensions.barPadding : tl_x(d.burst_start) + 0.66667*dimensions.barPadding;
							}
						})
						.attr("y", function(d, i) {
							return ((margin.top * 2.175) + (i * (dimensions.barHeight + dimensions.barPadding)));
						})
			            .on("click", function(d) {
			            	// https://octoperf.com/blog/2018/04/18/d3-js-drag-and-drop-tutorial/
			            	if (d3v5.event.ctrlKey) {
		            			exclusion_list.push(d.name);
					            // d3v5.select(this).remove();
					            // d3v5.select("rect[class=phrase]#bar_" + getID(d.name)).remove();
					            d3.selectAll("#line_" + getID(d.name)).remove();
							    d3.selectAll("#bar_" + getID(d.name)).remove();
					            tl_tooltip.style("opacity", 0);
					        } else {
			            		displayModal(d, 'name');
					        }
					        d3v5.event.stopPropagation();

					        // display exclusion list
							ex_list = d3v5.select("#ex_list")
										  .selectAll("option")
									      .data(exclusion_list)
									      .enter()
									      .append("option")
									      .text(function(phrase, i) { return phrase; })
									      .attr("value", function (phrase, i) { return i; })
									      .on("click", function(phrase) {
										      	if (d3v5.event.ctrlKey) {
										      		// remove phrase from exclusion_list
										      		var index = exclusion_list.indexOf(phrase);
										      		if (index > -1) { exclusion_list.splice(index, 1); }
										            d3v5.select(this).remove();
										            updateCharts();
										        }

										        d3v5.event.stopPropagation();
									      })
									      .exit()
									      .remove();
			            });

					tl_svg.selectAll(".phrase")
					   .attr("cursor", "pointer")
					   .on("mouseover", function(d) {

						    tl_tooltip.transition()		
						           .duration(200)		
						           .style("opacity", 1);
						
						    tl_tooltip.html(`<b>${d.name}</b><br>Began: ${d.burst_start.getFullYear()}<br>Ended: ${d.burst_end.getFullYear()}`)
						           .style("top", (d3v5.event.pageY - 10)+"px").style("left",(d3v5.event.pageX + 10)+"px");
					    
					    })
					 	.on("mouseout", function(d) {		
					    	tl_tooltip.transition()		
					           	   .duration(200)		
					           	   .style("opacity", 0);	
					    });

					d3v5.select("input[type = range]#num_phrases")
						.attr("min", 0)
						.attr("max", total_num_bursts)
						.attr("step", 1)
						.attr("value", num_to_plot)
						.on("input", function() {
						  	d3v5.select("output#num_display").text(this.value);
						})
						.on("change", function() {
							num_bursts_to_plot = this.value;
							// get selected CASC
							tl_selectedCascIndex = tl_casc_dropdown.property('selectedIndex');
							var selected_casc = cascs[tl_selectedCascIndex];

							new_num_to_plot = +d3v5.select("output#num_display").property("value");
							updateTimeline(selected_casc, num_bursts_to_plot, tl_selected_sort, ascending);
						 });


					// var deltaX, deltaY;

					// dragHandler = d3v5.drag()
					// 			      .on("start", function () {
					// 			        current = d3v5.select(this);
					// 			        deltaX = current.attr("x") - d3v5.event.x;
					// 			        deltaY = current.attr("y") - d3v5.event.y;
					// 			      })
					// 			      .on("drag", function () {
					// 			        d3v5.select(this)
					// 			            .attr("x", d3v5.event.x + deltaX)
					// 			            .attr("y", d3v5.event.y + deltaY);
					// 			      });

					// dragHandler(tl_svg.selectAll("rect"));

				})
				.catch(function(error) {
					console.log(exclusions_file + ' does not exist yet.');
				});
			});

		});
	}

	function processText(text, lowercase = false) {

		// https://stackoverflow.com/a/49123671/8379443
		if (lowercase) { text = text.toLowerCase(); }
		text = text.replace(/(<.*?>)/g, s0 => '');
		// text = text.replace(/([\.\(\)\[\]/])/g, s0 => ' ');
		text = text.replace(/(&nbsp;)/g, s0 => ' ');
		text = text.replace(/(â€™)/g, s0 => '');

		return text;
	}

	function getID(phrase) {

		phrase = processText(phrase);
		phrase = phrase.replace(/\s+/g, '_').replace(/(%)/g, s0 => '').replace(/(=)/g, s0 => '');

		return phrase;

	}

	var dictColumn = (dict, key) => dict.map(entry => entry[key]);

	function displayModal(burst, phrase_key) {

		phrase = burst[phrase_key];

		// set modal title
		$('.projModal-header h5').html(phrase);

		// create regex that that will be used to search each summary for this phrase
		words = phrase.split(" ");
		if (words.length == 2) {
			// create regex for phrase
			regex_filter = " *[a-z\(\)\-]* *"; // first word + 0 or more spaces + 0 or more characters + 0 or more spaces + second word
			phrase = words.join(regex_filter);
		}
		phrase = '[^a-z]' + phrase;
		regexp = new RegExp(`${phrase}`, "gi");

		// get the current casc
		if (phrase_key == 'name') { // the request is from the timeline viz
			selected_casc = d3v5.select("#tl_casc_dropdown option:checked").text();
			start_year = burst.burst_start.getFullYear();
			end_year = burst.burst_end.getFullYear();
		}
		else { // the request is from the line chart viz
			selected_casc = d3v5.select("#lc_casc_dropdown option:checked").text();
			start_year = d3v5.min(years);
			end_year = d3v5.max(years);
		}

		d3v5.json('/static/main/counts/master_details.json').then(function(data) {

			// filter for selected casc
			if (selected_casc != "All CASCs") {
				data = data.filter(function(d) {
					return d.casc.replace(" CASC", "") == selected_casc;
				});
			}

			// filter for years when this burst occured
			data = data.filter(function(d) {
				return d.year >= start_year && d.year <= end_year;
			})

			//get all rows whose summary contains this phrase
			data = data.filter(function(d) {

				summary = ' ' + processText(d.summary, lowercase = true); // prepend a space for our regex matching to match occurences at the start of the string
				match = summary.match(regexp);

				return match !== null;
			});

			// Modal details
			details = '';
			// get set of projects for this filtered data
			projects = new Set(dictColumn(data, 'projectTitle'))
			// for each project:
			proj_num = 0;
			num_projects = projects.size;
			projects.forEach(function(proj_title) {
				// get the data subset containing this project title
				proj_group = data.filter(function(d) {
					return d.projectTitle == proj_title;
				});

				casc_set = new Set(dictColumn(proj_group, 'casc'));
				
				proj_num += 1;
				details += '<h6><p><b>Project ' + proj_num + '/' + num_projects + ' (' + Array.from(casc_set).join(', ') + ' ' + proj_group[0].year + ')</b><p><h6>';
				// details += '<b>Project ' + proj_num + '</b>';
				details += '<p><b><a href = "' + proj_group[0].project_url + '" target = "_blank">' + proj_title + '</a></b><p>';
				details += '<p><b>Items</b><p>';

				// get set of items for this project group
				items = new Set(dictColumn(proj_group, 'title'));
				// for each item:
				item_num = 0;
				num_items = items.size;
				items.forEach(function(item_title) {
					// get the project group subset containing this item title
					item_group = proj_group.filter(function(d) {
						return d.title == item_title;
					});

					item_num += 1;
					details += '<p>' + item_num + '/' + num_items + ') <a href = "' + item_group[0].url + '" target = "_blank">' + item_title + '</a></p>';
					details += 'Abstract';
					// display summary, highlighting occurences of phrase
					details += '<p>';
					// prepend a space for our regex matching to match occurences at the start of the string
					s = ' ' + processText(item_group[0].summary);
					matches = s.match(regexp);
					if (matches) {
						end = 0;
						matches.forEach(function(match) {
							start = s.indexOf(match.slice(1), end);
							details += s.slice(end, start);
							end = start + match.length - 1;
							// highlight the match
							details += '<mark>' + s.slice(start, end) + '</mark>';
						})
						// append whatever summary is leftover and close out the paragraph
						details += s.slice(end) + '</p><br>';
					}
				});

				details += '<hr>'; // draw a line between projects
			});

			// write details to the modal
			details_div = document.getElementById('details_div');
			details_div.innerHTML = details;
		});

		// Add close functionality to the modal's close button
		var span = $('#modal').find('.close');
		span.on('click', function() {
			let modal = document.getElementById('modal');
			modal.style.display = 'none';
		})

		// Display the modal
		document.getElementById('modal').style.display = 'block';
	}

	// https://stackoverflow.com/a/55584453/8379443
	// convert JSON to CSV
	downloadCSVFromJson = (source) => {
		
		const replacer = (key, value) => value === null ? '' : value // specify how you want to handle null values here

		if (source == 'timeline') {
			selectedIndex = tl_casc_dropdown.property('selectedIndex');
			selected_casc = cascs[selectedIndex].toLowerCase().replace(' cascs', '').replace(' ', '_');
			burst_file = selected_casc + '_bursts.json';
		}
		else{
			selectedIndex = lc_casc_dropdown.property('selectedIndex');
			selected_casc = cascs[selectedIndex].toLowerCase().replace(' cascs', '').replace(' ', '_');
			burst_file = selected_casc + '_phrase_trends.json';
		}

		d3v5.json(bursts_data_path + burst_file).then(function(burst_data) {

			// filter out all_excluded_phrases
			burst_data = burst_data.filter(function(d) {
				return all_excluded_phrases.indexOf(d.label) == -1;
			})

			if (source == 'timeline') {

				filename = selected_casc + '_pulses.csv'
				
				header = ['label', 'weight', 'begin', 'end']
				header_dict = {
					'weight': 'pulse strength',
					'begin': 'pulse start',
					'end': 'pulse end',
					'label': 'pulse'
				}

			}
			else{

				filename = selected_casc + '_bursts.csv'

				header = ['phrase', 'm', 'baseline_prop']
				header_dict = {
					'm': 'burst strength',
					'baseline_prop': 'burst threshold',
					'phrase': 'burst'
				}

			}

			let csv = burst_data.map(function(row) {
					return header.map(function(fieldName) {
							entry = (['begin', 'end'].indexOf(fieldName) > -1)? years[row[fieldName]] : (fieldName == 'label')? row[fieldName].replace(',', '') : row[fieldName]
							return JSON.stringify(entry, replacer)
						}
					).join(',')
				}
			)

			csv_header = header.map(h => header_dict[h])
			csv.unshift(csv_header.join(','))
			csv = csv.join('\r\n')

			// Create link and download
			link = document.createElement('a');
			link.setAttribute('href', 'data:text/csv;charset=utf-8,%EF%BB%BF' + encodeURIComponent(csv));
			link.setAttribute('download', filename);
			link.style.visibility = 'hidden';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		})

	};

	function writeExclusionList() {

		if (exclusion_list.length == 0) {
			swal("Oops!", "The exclusion list is empty.", "error");
			return;
		}

		$.ajax({
			method: "POST",
			url: "{{ url_for('main.write_exclusions') }}",
			async: true,
			data: { exclusions: exclusion_list }
		});

		exclusion_list = [];

		d3v5.select("#ex_list")
		    .selectAll("option")
	        .remove();

	    // sweet alert
	    swal("Exclusions confirmed!", "The removed phrases will no longer be included in future analysis.", "success");

	    // wait half a second to allow exclusion_list to be written to file before pulse updates
	    setTimeout(() => {
	    	updateCharts();
	    }, 500);

	}

	function updateCharts() {

		// timeline
		tl_selectedCascIndex = tl_casc_dropdown.property('selectedIndex');
		selected_casc = cascs[tl_selectedCascIndex];
		new_num_to_plot = +d3v5.select("output#num_display").property("value");
		updateTimeline(selected_casc, new_num_to_plot, tl_selected_sort, ascending);

		// line chart
		tl_selectedCascIndex = lc_casc_dropdown.property('selectedIndex');
		selected_casc = cascs[tl_selectedCascIndex];
		new_threshold = +d3v5.select("output#threshold_display").property("value");
		new_win_size = +d3v5.select("output#win_size_display").property("value");
		new_num_bursts = +d3v5.select("output#num_bursts_display").property("value");
		updateLineChart(selected_casc, new_threshold, new_win_size, new_num_bursts);

	}

	function updateLines() {


	}

	function updateLineChart(casc, p_threshold, win_size, num_bursts) {

		// remove previous svg content
		lc_svg.selectAll(".axis").remove();
		lc_svg.selectAll(".line").remove();
		d3v5.select('lc_svg').remove();
		d3v5.select('lc_casc_dropdown').remove();
		d3v5.select('phr_line').remove();
		d3v5.select('#lineChart_legend').selectAll('text').remove();
		d3v5.select('#lineChart_legend').selectAll('rect').remove();

		// set slider values
		d3v5.select("output#threshold_display").text(p_threshold);
		d3v5.select("output#win_size_display").text(win_size);
		d3v5.select("output#num_bursts_display").text(num_bursts);


		// get file names
		phrase_trends_file = casc.toLowerCase().replace(' cascs', '').replace(' ', '_') + '_phrase_trends.json';
		r_file = casc.toLowerCase().replace(' cascs', '').replace(' ', '_') + '_r.json';
		counts_file = casc.toLowerCase().replace(' cascs', '').replace(' ', '_') + '_counts.json';

		top_phrases = [];
		r_dict = {};

		d3v5.json(bursts_data_path + phrase_trends_file).then(function(phrase_trends_data) {

			d3v5.csv(static_data_path + exclusions_file).then(function(excluded_phrases) {
				
				all_excluded_phrases = d3v5.merge([dictColumn(excluded_phrases, 'phrase'), exclusion_list]);

				// filter out all_excluded_phrases
				phrase_trends_data = phrase_trends_data.filter(function(d) {
					return all_excluded_phrases.indexOf(d.phrase) == -1;
				})

				burst_count = phrase_trends_data.filter(function(d) {
					return d.baseline_prop >= p_threshold;
				});

				d3v5.select("output#threshold_bursts_display").text(burst_count.length);
				num_bursts = d3v5.min([num_bursts, burst_count.length]);

				// re-map burst domain to the color range
				lc_spreader = d3.scale.linear().domain(d3.extent([0, num_bursts - 1])).range([0, max_num_bursts - 1]);
				// colors = [];
				// for (i = 0; i < num_bursts; i++) {
				// 	colors.push(d3.interpolateWarm(lc_color_map(lc_spreader(i))));
				// }
				
				// max value of baseline_prop
				threshold_max = phrase_trends_data.reduce(function(maxv, d) {
					return d3.max([maxv, d.baseline_prop]); 
				}, 0);

				trending_phrases = phrase_trends_data.filter(function(d) {
					return d.baseline_prop >= p_threshold;
				}).sort(function(a, b) {
					return d3v5.descending(a.m, b.m);
				}).slice(0, num_bursts);

				trending_phrases.forEach(function(d) {
					top_phrases.push(d.phrase);
					// initialize r_dict
					r_dict[d.phrase] = {
						'phrase': d.phrase,
						'values': []
					};
				})

				d3v5.json(bursts_data_path + r_file).then(function(r_data) {

					r_data = r_data.filter(function(d) {
						return top_phrases.indexOf(d.phrase) >= 0;
					});

					r_data.forEach(function(d) {
						r_dict[d.phrase].values.push(d.value);
					});

					d3v5.json(counts_data_path + counts_file).then(function(counts_data) {

						maxval = 0;
						burst_data = [];

						counts_data = counts_data.sort(function(a, b) {
							return d3v5.ascending(a.year, b.year);
						});

						proj_counts = dictColumn(counts_data, 'project_count');
						casc_years = dictColumn(counts_data, 'year');

						// divide r by proj_counts
						for (phrase in r_dict) {
							for (i = 0; i < proj_counts.length; i++) {
								r_dict[phrase].values[i] = r_dict[phrase].values[i]/proj_counts[i];
							}
						}

						// calculate the rolling mean for each column in r
						for (phrase in r_dict) {
							r_dict[phrase].values = rollingMean(r_dict[phrase].values, win_size);
						}

						// fill in missing years
						for (phrase in r_dict) {
							new_values = [];
							for (i = 0; i < years.length; i++) {
								val = 0;
								index = casc_years.indexOf(years[i]);
								if (index >= 0 && r_dict[phrase].values[index] != null) {

									val = +r_dict[phrase].values[index];

									if (val > maxval) { maxval = val; }
								}
								new_values.push([years[i], val]);
							}
							r_dict[phrase].values = new_values;
							burst_data.push({
								'phrase': phrase,
								'values': new_values
							});
						}

					    y.domain([0, maxval]).nice();

						// // Nest the entries by phrase
					 //    dataNest = d3v5.nest()
						// 	           .key(function(d) { return d.phrase; })
						// 	           .entries(Object.values(r_dict));

						// burst_data.forEach(function(d, i) {
						// 	d.color = d3.interpolateWarm(lc_color_map(lc_spreader(i)));
						// })

						active_list = burst_data.map(d => d.phrase);
						// modify curr_list and color_dict
						// curr_list = (slice_mode == 'threshold')? curr_list.slice(-num_bursts) : curr_list.slice(0, num_bursts);
						current_phrases = Object.keys(color_dict);
						current_phrases.forEach(function(phrase) {
							if (active_list.indexOf(phrase) < 0) {
								// mark this phrase's color as available
								available_color = color_dict[phrase];
								available_index = colors.indexOf(available_color);
								color_status[available_index] = 'available';
								// delete 'phrase' from the dictionary
								delete color_dict[phrase];
							}
						})

						lc_legend = d3.select("#lineChart_legend")
									  .attr("height", num_bursts * 15)
									  .selectAll("text")
									  .data(burst_data, function(d){ return d.phrase });
						
						// reduceC = (col, c) => col.substring(4, col.length - 1).replace(/ /g, '').split(',').map(s => s.split('').map(d => c[0] += +d));

						//checkboxes
						lc_legend.enter()
								 .append("rect")
								 .attr("id", function(d){ return "line_" + getID(d.phrase); })
								 .attr("width", 10)
								 .attr("height", 10)
								 .attr("x", 0)
								 .attr("y", function (d, i) { return 0 + i*15; })  // spacing
								 .attr("fill", function(d, i) {

								 	// assign each phrase/line color
								 	if (Object.keys(color_dict).indexOf(d.phrase) < 0) {
								 		// get next available color
								 		available_index = color_status.indexOf('available');
								 		available_color = colors[available_index];
								 		color_dict[d.phrase] = available_color;
								 		// mark this color as unavailable
								 		color_status[available_index] = 'unavailable';
								 	}

								 	// curr_list.push(d.phrase);
								 	// console.log(color_dict[d.phrase]);
								  	// return colors[i];
								  	return color_dict[d.phrase];
								    
								 })
								 .attr("class", function(d, i) { return "legendcheckbox " + d.phrase })
								 .on("click", function(d, i){

								 	// flipped_on = false;

								 	// flip the rectangle color
									d3.select(this).attr("fill", function(d){
										if(d3.select(this).attr("fill")  == "#ccc"){
											return color_dict[d.phrase];
										}else {
											return "#ccc";
										}
									})

									var line_color = color_dict[d.phrase];
									d3.selectAll(".line").each(function(d) {
										if (color_dict[d.phrase] == line_color) {
											var opacity = d3.select(this).style("opacity");
											// flip the opacity
											d3.select(this).style("opacity", 1 - opacity);

										}
									});

								 });

					    // Add the Legend text
					    lc_legend.enter()
						    	 .append("text")
								 .attr("id", function(d){ return "line_" + getID(d.phrase); })
							     .attr("x", 15)
							     .attr("y", function(d, i){ return 10 + i*15; })
							     .attr("class", "chart_legend")
					             .on("mouseover", function() {
					            	d3.select(this)
					            	  .style("cursor", "pointer");
					             })
					             .on("click", function(d) {
					             	// https://octoperf.com/blog/2018/04/18/d3-js-drag-and-drop-tutorial/
					            	if (d3.event.ctrlKey) {
					            		exclusion_list.push(d.phrase);
							            // d3.select(this).remove();
							            // remove the corresponding line and legend checkbox (they have the same id)
							            d3.selectAll("#line_" + getID(d.phrase)).remove();
							            d3.selectAll("#bar_" + getID(d.phrase)).remove();
							            // d3.select("rect#" + getID(d.phrase)).remove();
							        } else {
					            		displayModal(d, 'phrase');
							        }
							        d3.event.stopPropagation();

							        // display exclusion list
									ex_list = d3v5.select("#ex_list")
												  .selectAll("option")
											      .data(exclusion_list)
											      .enter()
											      .append("option")
											      .text(function(phrase, i) { return phrase; })
											      .attr("value", function (phrase, i) { return i; })
											      .on("click", function(phrase) {
												      	if (d3v5.event.ctrlKey) {
												      		// remove phrase from exclusion_list and redo line chart
												      		var index = exclusion_list.indexOf(phrase);
												      		if (index > -1) { exclusion_list.splice(index, 1); }
												            d3v5.select(this).remove();
												            updateCharts();
												        }
												        d3v5.event.stopPropagation();
											      })
											      .exit()
											      .remove();
					             });

						lc_legend.style("fill", "#777" )
								 .text(function(d) { return d.phrase; });

						lc_legend.exit().remove();


					    x.domain(d3.extent(years, function(d) { return d; }));

						var phr_line = lc_svg.selectAll(".line")
					 					     .data(burst_data, function(d) { return d.phrase })
					 					     .enter()
					 					     .append("path")
					 					     .attr("class", "line")
										     .on('mouseover', function(d) {
											    // Show tl_tooltip only if the line is currently visible
											    if (d3.select(this).style("opacity") == 1) {
												    d3.select('.lc_tooltip')
											          .style('visibility','visible')
											          .style('top', d3.event.pageY + 10 + 'px')
											          .style('left', d3.event.pageX + 10 + 'px')
											          .html('<b>' + d.phrase);										    	
											    }
										     })
										     .on('mouseout', function(d) {
											    // Hide tl_tooltip
											    d3.select('.lc_tooltip').style('visibility', 'hidden');
										    });

						phr_line.transition()
								.style("stroke", function(d, i) { 
									// return d.color = colors[i % num_bursts];
									return color_dict[d.phrase];
								})
								.attr("id", function(d){ return "line_" + getID(d.phrase);})
								.attr("d", function(d){
									return phraseline(d.values);
								});

						// phr_line.exit().remove();

					    // Add the X Axis
					    lc_svg.append("g")
						      .attr("class", "x axis")
						      .attr("transform", "translate(0," + lc_height + ")")
						      .call(xAxis);

					    // Add the Y Axis
					    lc_svg.append("g")
						      .attr("class", "y axis")
						      .call(yAxis)
						      .append("text")
						      .attr("transform", "rotate(-90)")
						      .attr("y", 6)
						      .attr("dy", ".71em")
						      .style("text-anchor", "end")
						      // .style('font-weight','bold')
						      .text("Relative Frequency");

						d3v5.select("input[type = range]#threshold")
							.attr("min", 0)
							.attr("max", threshold_max)
							.attr("step", threshold_max/100)
							.attr("value", p_threshold)
							.on("input", function() {
							  	d3v5.select("output#threshold_display").text(this.value);
							})
							.on("change", function() {
								new_threshold = +this.value;

								// get selected CASC
								tl_selectedCascIndex = lc_casc_dropdown.property('selectedIndex');
								var selected_casc = cascs[tl_selectedCascIndex];

								new_win_size = +d3v5.select("output#win_size_display").property("value");
								new_num_bursts = +d3v5.select("output#num_bursts_display").property("value");
								updateLineChart(selected_casc, new_threshold, new_win_size, new_num_bursts);
							 });

						d3v5.select("input[type = range]#win_size")
							.attr("min", 1)
							.attr("max", max_win_size)
							.attr("step", 1)
							.attr("value", win_size)
							.on("input", function() {
							  	d3v5.select("output#win_size_display").text(this.value);
							})
							.on("change", function() {
								new_win_size = +this.value;
								// get selected CASC
								tl_selectedCascIndex = lc_casc_dropdown.property('selectedIndex');
								var selected_casc = cascs[tl_selectedCascIndex];

								new_threshold = +d3v5.select("output#threshold_display").property("value");
								new_num_bursts = +d3v5.select("output#num_bursts_display").property("value");
								updateLineChart(selected_casc, new_threshold, new_win_size, new_num_bursts);
							 });

						d3v5.select("input[type = range]#num_bursts")
							.attr("min", 1)
							.attr("max", max_num_bursts)
							.attr("step", 1)
							.attr("value", num_bursts)
							.on("input", function() {
							  	d3v5.select("output#num_bursts_display").text(this.value);
							})
							.on("change", function() {
								new_num_bursts = +this.value;

								// get selected CASC
								tl_selectedCascIndex = lc_casc_dropdown.property('selectedIndex');
								var selected_casc = cascs[tl_selectedCascIndex];

								new_threshold = +d3v5.select("output#threshold_display").property("value");
								new_win_size = +d3v5.select("output#win_size_display").property("value");
								updateLineChart(selected_casc, new_threshold, new_win_size, new_num_bursts);
							 });

					});

				});
			})
			.catch(function(error) {
				console.log(exclusions_file + ' does not exist yet.');
			});

		});

	}

	function showAll(){

		// repopulate curr_list
		// curr_list = master_list.slice();

		// fill in all rectangle colors
		d3.select("#lineChart_legend").selectAll("rect")
		  .attr("fill",function(d, i) {
		  	// return colors[i];
		  	// return d.color;
		  	// return d3.interpolateWarm(lc_color_map(i));
		  	return color_dict[d.phrase];
		  });

		// make all lines visible
		d3.selectAll(".line")
		  .style("opacity", 1);

	};

	function clearAll(){

		// clear curr_list
		// curr_list = [];

		// grey out all rectangles
		d3.select("#lineChart_legend").selectAll("rect")
		  .attr("fill", "#ccc");

		// hide all lines
		d3.selectAll(".line")
		  .style("opacity", 0);

	};

		
	// Source: https://stackoverflow.com/a/39263992/8379443
	/**
    * returns an array with moving average of the input array
    * @param array - the input array
    * @param count - the number of elements to include in the moving average calculation
    * @param qualifier - an optional function that will be called on each 
    *  value to determine whether it should be used
    */
    function rollingMean(array, window_size, qualifier){

        // calculate average for subarray
        var avg = function(arr, qualifier){

            var sum = 0, w_size = 0, val;

            for (var i in arr){
                val = arr[i];
                if (!qualifier || qualifier(val)){
                    sum += val;
                    w_size++;
                }
            }

            return sum / w_size;
        };

        var result = [], v;

        // pad beginning of result with null values
        for (var i = 0; i < window_size - 1; i++)
            result.push(null);

        // calculate average for each subarray and add to result
        for (var i = 0, len = array.length - window_size; i <= len; i++){

            v = avg(array.slice(i, i + window_size), qualifier);
            if (isNaN(v))
                result.push(null);
            else
                result.push(v);
        }

        return result;
    }


    // Generate initial visualizations
	updateTimeline(default_casc, default_num_bursts, tl_selected_sort, ascending);
	updateLineChart(default_casc, default_p_threshold, default_win_size, default_num_bursts);

	// When the user clicks anywhere outside of the modal, close it
	window.onclick = function(event) {
		if ($(event.target).hasClass('projModal')) {
			let modal = document.getElementById(event.target.id);
			modal.style.display = 'none';
		}
	}

	// let currentPage = document.getElementById('Nav-Proj-Compare');
	// currentPage.classList.add("currentPage");

</script>

{% endblock %}
